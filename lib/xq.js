// Generated by CoffeeScript 1.8.0
(function() {
  var ALWAYS, FIN, INI, NVA, SERIAL, X, alwaysResolver, cnt, doneResolver, failResolver, forEachResolver, makeResolver, nextTick, safeCall, stepWith, thenResolver, unitFe, unitFx, unwrap,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  INI = {
    ini: 0
  };

  FIN = {
    fin: 0
  };

  NVA = {
    nva: 0
  };

  cnt = 0;

  module.exports = X = (function() {
    X.prototype._value = INI;

    X.prototype._isError = false;

    X.prototype._isEnded = false;

    X.prototype._isEnding = false;

    X.prototype._type = 'root';

    X.prototype._resolver = null;

    X.prototype._fx = null;

    X.prototype._fe = null;

    X.prototype._prev = null;

    X.prototype._next = null;

    X.prototype._execCount = 0;

    X.prototype._serial = false;

    X.prototype._head = null;

    X.prototype._tail = null;

    X.prototype._onEnd = null;

    X.prototype.inspect = function() {
      var v;
      v = this._value === INI ? '_' : this._value + '';
      return ("{" + this._type + this._cnt + ": v:" + v + ", err:" + this._isError + ", ") + ("end:" + this._isEnded + ", exec:" + this._execCount + ", ser:" + this._serial + "}");
    };

    function X(v) {
      this._doEnd = __bind(this._doEnd, this);
      this._resolverExit = __bind(this._resolverExit, this);
      this._end = __bind(this._end, this);
      this._reject = __bind(this._reject, this);
      this._resolve = __bind(this._resolve, this);
      this._pushError = __bind(this._pushError, this);
      this._push = __bind(this._push, this);
      var a;
      if (!(this instanceof X)) {
        return new X(v);
      }
      this._cnt = cnt++;
      if (v instanceof X) {
        v._addNext(this);
      } else {
        this._value = v;
        if (typeof (a = arguments[1]) === 'boolean') {
          this._isError = a;
        }
        this._isEnded = v !== INI;
      }
      this._makeSerial();
    }

    X.reject = function(reason) {
      return new X(reason, true);
    };

    X.defer = function(v) {
      return new X(INI)._defer(v);
    };

    X.prototype.isPending = function() {
      return !this._isEnded;
    };

    X.prototype.isEnded = function() {
      return this._isEnded;
    };

    X.prototype.isRejected = function() {
      return this._isEnded && this._isError;
    };

    X.prototype.isFulfilled = function() {
      return this._isEnded && !this._isError;
    };

    X.prototype._defer = function(v) {
      var _this;
      if (v !== void 0) {
        this._push(v);
      }
      _this = this;
      return this._def || (this._def = {
        push: _this._push,
        pushError: _this._pushError,
        resolve: _this._resolve,
        reject: _this._reject,
        end: _this._end,
        promise: _this
      });
    };

    X.prototype._push = function(v) {
      return this._exec(v, false);
    };

    X.prototype._pushError = function(e) {
      return this._exec(e, true);
    };

    X.prototype._resolve = function(v) {
      return this._push(v)._end();
    };

    X.prototype._reject = function(e) {
      return this._pushError(e)._end();
    };

    X.prototype._end = function() {
      return this._exec(FIN, false);
    };

    X.prototype._exec = function(v, isError, fromQueue) {
      var _ref;
      if (this._isEnded || (this._isEnding && !fromQueue)) {
        return this;
      }
      if (v === FIN) {
        this._isEnding = true;
        if (this._execCount === 0 && !((_ref = this._head) != null ? _ref.next : void 0)) {
          this._doEnd();
        }
        return this;
      }
      if (this._serial && this._execCount > 0) {
        this._enqueue(v, isError);
        return this;
      }
      this._execCount++;
      if (!this._resolver(this._fx, this._fe, v, isError, this._resolverExit)) {
        this._resolverExit(v, isError);
      }
      return this;
    };

    X.prototype._enqueue = function(v, isError) {
      if (!this._head) {
        this._head = {
          next: null
        };
        this._tail = this._head;
      }
      return this._tail = this._tail.next = {
        next: null,
        v: v,
        isError: isError
      };
    };

    X.prototype._nextEvent = function() {
      if (!(this._head && this._head.next)) {
        return null;
      }
      return this._head = this._head.next;
    };

    X.prototype._execNext = function() {
      var next;
      if (this._execCount === 0 && (next = this._nextEvent())) {
        this._exec(next.v, next.isError, true);
      }
      return this;
    };

    X.prototype._resolver = function(fx, fe, v, isError, cb) {
      unwrap(v, isError, cb);
      return true;
    };

    X.prototype._resolverExit = function(v, isError, ended) {
      var _ref;
      if (ended) {
        this._execCount--;
      }
      this._setValue(v, isError);
      if (this._isEnding && this._execCount === 0 && !((_ref = this._head) != null ? _ref.next : void 0)) {
        this._doEnd();
      }
      return this._execNext();
    };

    X.prototype._doEnd = function() {
      var f, _i, _len, _ref, _ref1;
      this._isEnded = true;
      if ((_ref = this._prev) != null) {
        _ref._removeNext(this);
      }
      if (this._onEnd) {
        _ref1 = this._onEnd;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          f = _ref1[_i];
          safeCall(f, this);
        }
      }
      this._forward(FIN, false);
      return this;
    };

    X.prototype._setValue = function(v, isError) {
      if (this._isEnded || v === NVA) {
        return this;
      }
      this._value = v;
      this._isError = isError;
      return this._forward(v, isError);
    };

    X.prototype._forward = function(v, isError) {
      var _ref;
      if (!((_ref = this._next) != null ? _ref.length : void 0)) {
        return this;
      }
      this._next.forEach(function(n) {
        return n._exec(v, isError);
      });
      return this;
    };

    X.prototype._addNext = function(n) {
      if (!this._next) {
        this._next = [];
      }
      this._next.push(n);
      n._prev = this;
      if (this._value !== INI) {
        n._exec(this._value, this._isError);
        if (this._isEnded && !n._isEnded) {
          n._exec(FIN, false);
        }
      }
      return n;
    };

    X.prototype._removeNext = function(n) {
      var i;
      delete n._prev;
      if (i = this._next.indexOf(n) >= 0) {
        this._next.splice(i, 1);
      }
      return this;
    };

    X.prototype._makeSerial = function() {
      SERIAL.forEach((function(_this) {
        return function(f) {
          return _this[f].serial = function(fx, fe) {
            return _this[f].call(_this, {
              serial: true
            }, fx, fe);
          };
        };
      })(this));
      return this;
    };

    X.prototype.onEnd = function(f) {
      if (!this._onEnd) {
        this._onEnd = [];
      }
      this._onEnd.push(f);
      if (this._isEnded) {
        safeCall(f, this);
      }
      return this;
    };

    return X;

  })();

  safeCall = function(f, v) {
    var err;
    try {
      return f(v);
    } catch (_error) {
      err = _error;
    }
  };

  ALWAYS = {
    always: 0
  };

  nextTick = require('../lib/nexttick');

  makeResolver = function(mode) {
    return function(fx, fe, v, isError, cb) {
      var f, schedule, _this;
      f = mode === ALWAYS || mode === isError ? fx : mode === false && isError === true ? fe : void 0;
      if (!f) {
        return false;
      }
      _this = this;
      schedule = this._immediate ? function(task) {
        return task();
      } : nextTick;
      schedule(function() {
        var err, r;
        try {
          r = f.apply(void 0, mode === ALWAYS ? [v, isError] : [v]);
          if (r === _this) {
            throw new TypeError('f returned same promise');
          }
          return unwrap(r, false, cb);
        } catch (_error) {
          err = _error;
          return unwrap(err, true, cb);
        }
      });
      return true;
    };
  };

  unitFx = function(x) {
    return x;
  };

  unitFe = function(e) {
    throw e;
  };

  stepWith = function(type, resolver, twoF, finish) {
    return function(opts, fx, fe) {
      var p;
      if (typeof opts !== 'object') {
        fe = fx;
        fx = opts;
        opts = null;
      }
      if (!fx) {
        fx = unitFx;
      }
      if (!(!twoF || fe)) {
        fe = unitFe;
      }
      p = new X(INI);
      p._type = type;
      p._resolver = resolver;
      p._fx = fx;
      if (twoF) {
        p._fe = fe;
      }
      p._serial = !!(opts != null ? opts.serial : void 0);
      p._immediate = !!(opts != null ? opts.immediate : void 0);
      this._addNext(p);
      if (finish) {
        return void 0;
      } else {
        return p;
      }
    };
  };

  thenResolver = makeResolver(false);

  failResolver = makeResolver(true);

  alwaysResolver = makeResolver(ALWAYS);

  X.prototype.then = X.prototype.map = stepWith('then', thenResolver, true);

  X.prototype.fail = X.prototype["catch"] = stepWith('fail', failResolver);

  X.prototype.always = X.prototype.fin = X.prototype["finally"] = stepWith('always', alwaysResolver);

  X.prototype._always = stepWith('[always]', alwaysResolver);

  X.prototype.spread = stepWith('spread', function(fx, fe, v, isError, cb) {
    var argv, f;
    argv = Array.isArray(v) ? v : [v];
    f = function() {
      return fx.apply(void 0, argv);
    };
    return thenResolver.call(this, f, void 0, v, isError, cb);
  });

  doneResolver = function(fx, fe, v, isError, cb) {
    if (isError && !fe || fe === unitFe) {
      fe = function() {
        return nextTick(function() {
          throw (v instanceof Error ? v : new Error(v));
        });
      };
      if ((typeof process !== "undefined" && process !== null ? process.domain : void 0) != null) {
        fe = process.domain.bind(fe);
      }
    }
    return thenResolver.call(this, fx, fe, v, isError, cb);
  };

  X.prototype.done = stepWith('done', doneResolver, true, true);

  forEachResolver = function(fx, fe, v, isError, cb) {
    var arr, takeOne, _this;
    if (!isError && Array.isArray(v)) {
      if (v.length === 0) {
        cb(NVA, false, true);
        return true;
      }
      arr = v.slice(0);
      _this = this;
      if (!_this._serial) {
        this._execCount += arr.length - 1;
      }
      (takeOne = function() {
        var x;
        if (arr.length === 0) {
          if (_this._serial) {
            cb(NVA, false, true);
          }
          return;
        }
        x = arr.shift();
        return unwrap(x, false, function(v, isError) {
          if (v === NVA) {
            return;
          }
          if (_this._serial) {
            _this._enqueue(v, isError);
          } else {
            if (!thenResolver.call(_this, fx, fe, v, isError, cb)) {
              cb(v, isError, false);
            }
          }
          return takeOne();
        });
      })();
      return true;
    } else {
      return thenResolver.call(this, fx, fe, v, isError, cb);
    }
  };

  X.prototype.forEach = stepWith('forEach', forEachResolver);

  SERIAL = ['then', 'fail', 'always', 'spread', 'forEach'];

  unwrap = function(v, isError, cb, ended) {
    if (ended == null) {
      ended = true;
    }
    if (v instanceof X) {
      v._always({
        immediate: true
      }, function(v, isError) {
        unwrap(v, isError, cb, false);
        return null;
      });
      return v.onEnd(function() {
        return unwrap(NVA, false, cb, ended);
      });
    } else {
      return cb(v, isError, ended);
    }
  };

}).call(this);
